<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>California Wildfire Resilience Network</title>
    
    <script src="https://cdn.tailwindcss.com"></script>
    
    <script src="https://unpkg.com/vue@3/dist/vue.global.js"></script>
    
    <script src="https://d3js.org/d3.v7.min.js"></script>
    
    <script src="https://unpkg.com/topojson-client@3"></script>

    <style>
        body { font-family: 'Inter', sans-serif; }
        
        /* Map Container */
        #map-container {
            background-color: #ffffff;
            width: 100%;
            height: 100vh;
            overflow: hidden;
            position: relative;
        }

        /* SVG Elements */
        .county {
            fill: #D1D5DB; /* Gray-300 */
            stroke: #FFFFFF;
            stroke-width: 0.5px;
            transition: fill 0.3s ease;
        }
        .county:hover {
            fill: #9CA3AF; /* Gray-400 */
        }

        .link {
            stroke: #374151; /* Gray-700 */
            stroke-opacity: 0.2;
            pointer-events: none;
        }

        .link.highlighted {
            stroke: #F97316; /* Orange-500 */
            stroke-opacity: 1;
        }

        .node-circle {
            fill: #FFFFFF;
            stroke: #F97316; /* Orange-500 */
            cursor: pointer;
        }

        .node-circle:hover {
            stroke: #EA580C; /* Orange-600 */
        }

        .node-circle.project {
            stroke: #0EA5E9; /* Sky-500 */
        }

        .node-circle.project:hover {
            stroke: #0284C7; /* Sky-600 */
        }

        .node-circle.faded {
            opacity: 0.4;
        }

        .link.faded {
            stroke-opacity: 0.1;
        }

        /* Tooltip */
        .tooltip {
            position: absolute;
            background: #1F2937; /* Gray-800 */
            color: white;
            padding: 8px 12px;
            border-radius: 6px;
            font-size: 12px;
            pointer-events: none;
            opacity: 0;
            transition: opacity 0.2s;
            transform: translate(-50%, -120%);
            box-shadow: 0 4px 6px -1px rgba(0, 0, 0, 0.1);
            z-index: 50;
        }

        /* Transitions */
        .fade-enter-active, .fade-leave-active {
            transition: opacity 0.5s ease;
        }
        .fade-enter-from, .fade-leave-to {
            opacity: 0;
        }
    </style>
</head>
<body>

<div id="app" class="relative w-full h-full">
    
    <div class="absolute top-6 left-1/2 transform -translate-x-1/2 z-20 flex flex-col md:flex-row gap-4 items-center w-full max-w-4xl px-4 pointer-events-none">
        <div class="pointer-events-auto bg-white shadow-lg rounded-md overflow-hidden flex items-center h-10 w-48 border border-gray-200">
            <input type="text" placeholder="Search..." class="w-full h-full px-3 text-sm outline-none text-gray-700" v-model="searchQuery">
        </div>

        <div class="pointer-events-auto bg-white shadow-lg rounded-md flex overflow-hidden border border-gray-200">
            <button
                v-for="tab in tabs"
                :key="tab"
                @click="selectTab(tab)"
                :class="['px-6 py-2 text-sm font-medium transition-colors', activeTab === tab ? 'bg-gray-800 text-white' : 'text-gray-600 hover:bg-gray-50']"
            >
                {{ tab }}
            </button>
        </div>
        
    </div>

    <div class="absolute top-6 right-6 z-20 pointer-events-auto bg-gray-800 text-white p-4 rounded-md shadow-lg max-w-xs" v-if="selectedNode">
        <div class="font-semibold text-base mb-1">{{ selectedNode.name }}</div>
        <div class="text-sm text-gray-300 mb-3">{{ selectedNode.type === 'Institute' ? 'Organization' : selectedNode.type }} â€¢ {{ selectedNode.status }}</div>
        <div class="text-xs text-gray-400 uppercase tracking-wide mb-2">Connected to:</div>
        <div class="space-y-1 max-h-48 overflow-y-auto">
            <div v-for="conn in connectedNodes" :key="conn.id" class="text-sm flex items-center gap-2">
                <span class="w-2 h-2 rounded-full flex-shrink-0" :class="conn.type === 'Project' ? 'bg-sky-500' : 'bg-orange-500'"></span>
                <span class="text-white">{{ conn.name }}</span>
            </div>
            <div v-if="connectedNodes.length === 0" class="text-gray-500 text-sm italic">No connections</div>
        </div>
    </div>

    <div class="absolute bottom-6 left-6 z-20 pointer-events-auto bg-white shadow-lg rounded-md p-6 border border-gray-200">
        <div class="text-base font-semibold text-gray-700 mb-4">Legend</div>
        <div class="flex items-center gap-4 text-base text-gray-600 mb-2">
            <span class="w-8 h-8 rounded-full border-[5px] border-orange-500 bg-white inline-block"></span>
            Organization
        </div>
        <div class="flex items-center gap-4 text-base text-gray-600">
            <span class="w-8 h-8 rounded-full border-[5px] border-sky-500 bg-white inline-block"></span>
            Project
        </div>
    </div>

    <div class="absolute bottom-6 right-6 z-20 flex flex-col gap-2 pointer-events-auto">
        <button @click="zoomIn" class="bg-white hover:bg-gray-50 text-gray-700 w-10 h-10 rounded-md shadow-lg flex items-center justify-center border border-gray-200 text-xl font-bold">+</button>
        <button @click="zoomOut" class="bg-white hover:bg-gray-50 text-gray-700 w-10 h-10 rounded-md shadow-lg flex items-center justify-center border border-gray-200 text-xl font-bold">-</button>
    </div>

    <div id="map-container"></div>
    
    <div ref="tooltip" class="tooltip">
        <div class="font-bold text-sm">{{ tooltipData.name }}</div>
        <div class="text-xs text-gray-300">{{ tooltipData.type === 'Institute' ? 'Organization' : tooltipData.type }}</div>
        <div class="text-xs text-orange-400 mt-1">{{ tooltipData.status }}</div>
    </div>

</div>

<script>
    const { createApp, ref, onMounted, watch, computed, nextTick } = Vue;

    createApp({
        setup() {
            const tabs = ['Projects', 'Organizations', 'Partnerships'];
            const activeTab = ref('Partnerships');
            const searchQuery = ref('');
            const selectedNode = ref(null);
            const tooltipData = ref({ name: '', type: '', status: '' });
            const tooltip = ref(null);

            // D3 Variables
            let svg, g, projection, path, zoom;
            let currentZoomScale = 1;
            let simulation;
            
            // --- DATA GENERATED FROM CSV ---
            const graphData = {
              "nodes": [
                { "id": 0, "name": "Moore Foundation", "type": "Institute", "coordinates": [-122.1401, 37.4063], "status": "Active" },
                { "id": 1, "name": "National Forest Foundation", "type": "Institute", "coordinates": [-120.1888, 39.3189], "status": "Active" },
                { "id": 2, "name": "Burn Bot", "type": "Institute", "coordinates": [-122.4018, 37.6592], "status": "Active" },
                { "id": 3, "name": "Juniper Re", "type": "Institute", "coordinates": [-122.3987, 37.7996], "status": "Active" },
                { "id": 4, "name": "Teakettle", "type": "Project", "coordinates": [-119.0152, 36.9718], "status": "Active" },
                { "id": 5, "name": "Task Force", "type": "Institute", "coordinates": [-121.4657, 38.5991], "status": "Active" },
                { "id": 6, "name": "Fire Aside", "type": "Institute", "coordinates": [-122.5544, 37.9783], "status": "Active" },
                { "id": 7, "name": "PyroLogix", "type": "Institute", "coordinates": [-121.4881, 38.5821], "status": "Active" },
                { "id": 8, "name": "Vibrant Planet", "type": "Institute", "coordinates": [-120.1821, 39.3323], "status": "Active" },
                { "id": 9, "name": "RockRose Risk", "type": "Institute", "coordinates": [-122.2791, 38.2978], "status": "Active" },
                { "id": 10, "name": "Madronus", "type": "Institute", "coordinates": [-122.7126, 38.4468], "status": "Active" },
                { "id": 11, "name": "PG&E", "type": "Institute", "coordinates": [-122.4169, 37.7819], "status": "Active" },
                { "id": 12, "name": "Marin Fire Prevention Authority", "type": "Institute", "coordinates": [-122.7502, 38.0683], "status": "Active" },
                { "id": 13, "name": "XyloPlan", "type": "Institute", "coordinates": [-122.2662, 37.8728], "status": "Active" },
                { "id": 14, "name": "CALFIRE", "type": "Institute", "coordinates": [-121.5098, 38.5543], "status": "Active" },
                { "id": 15, "name": "Placerville", "type": "Project", "coordinates": [-120.7918, 38.7335], "status": "Active" },
                { "id": 16, "name": "Nevada City", "type": "Project", "coordinates": [-121.0105, 39.2646], "status": "Active" },
                { "id": 17, "name": "Planet", "type": "Institute", "coordinates": [-122.4037, 37.7929], "status": "Active" },
                { "id": 18, "name": "PlanScape", "type": "Institute", "coordinates": [-121.4757, 38.5796], "status": "Active" },
                { "id": 19, "name": "CWI", "type": "Institute", "coordinates": [-121.8656, 37.6674], "status": "Active" },
                { "id": 20, "name": "Grass Valley", "type": "Project", "coordinates": [-121.0506, 39.2212], "status": "Active" },
                { "id": 21, "name": "Incline Village", "type": "Project", "coordinates": [-119.9482, 39.2549], "status": "Active" },
                { "id": 22, "name": "Marin", "type": "Project", "coordinates": [-122.7380, 38.0608], "status": "Active" },
                { "id": 23, "name": "USFS", "type": "Institute", "coordinates": [-122.2501, 38.1083], "status": "Active" },
                { "id": 24, "name": "SIG", "type": "Institute", "coordinates": [-121.8759, 37.6745], "status": "Active" },
                { "id": 25, "name": "American Forest Foundation", "type": "Institute", "coordinates": [-121.497, 38.5659], "status": "Active" },
                { "id": 26, "name": "Tahoe Fund", "type": "Institute", "coordinates": [-120.1386, 39.1759], "status": "Active" }
              ],
              "links": [
                { "source": 11, "target": 16 }, { "source": 11, "target": 19 }, { "source": 11, "target": 12 },
                { "source": 11, "target": 17 }, { "source": 11, "target": 2 }, { "source": 11, "target": 13 },
                { "source": 11, "target": 15 }, { "source": 19, "target": 16 }, { "source": 19, "target": 17 },
                { "source": 19, "target": 0 }, { "source": 19, "target": 5 }, { "source": 19, "target": 15 },
                { "source": 19, "target": 21 }, { "source": 19, "target": 26 }, { "source": 19, "target": 2 },
                { "source": 19, "target": 4 }, { "source": 19, "target": 23 }, { "source": 19, "target": 14 },
                { "source": 12, "target": 22 }, { "source": 12, "target": 19 }, { "source": 12, "target": 6 },
                { "source": 6, "target": 19 }, { "source": 6, "target": 0 }, { "source": 6, "target": 16 },
                { "source": 6, "target": 20 }, { "source": 10, "target": 16 }, { "source": 10, "target": 19 },
                { "source": 10, "target": 11 }, { "source": 17, "target": 16 }, { "source": 17, "target": 5 },
                { "source": 13, "target": 16 }, { "source": 13, "target": 19 }, { "source": 13, "target": 0 },
                { "source": 8, "target": 16 }, { "source": 8, "target": 11 }, { "source": 8, "target": 26 },
                { "source": 9, "target": 16 }, { "source": 9, "target": 19 }, { "source": 9, "target": 11 },
                { "source": 3, "target": 16 }, { "source": 3, "target": 11 }, { "source": 7, "target": 16 },
                { "source": 7, "target": 8 }, { "source": 7, "target": 11 }, { "source": 18, "target": 16 },
                { "source": 18, "target": 24 }, { "source": 18, "target": 19 }, { "source": 18, "target": 11 },
                { "source": 24, "target": 16 }, { "source": 24, "target": 19 }, { "source": 24, "target": 11 },
                { "source": 25, "target": 16 }, { "source": 25, "target": 11 }, { "source": 1, "target": 16 },
                { "source": 1, "target": 11 }, { "source": 1, "target": 19 }
              ]
            };

            const filteredNodes = computed(() => {
                let nodes = graphData.nodes;
                const selected = selectedNode.value;

                // Search Filter - but skip if single match is already selected (show all for connections)
                if (searchQuery.value) {
                    const q = searchQuery.value.toLowerCase();
                    const matches = nodes.filter(n => n.name.toLowerCase().includes(q));

                    // Only filter if multiple matches or no selection
                    if (matches.length !== 1 || !selected || selected.id !== matches[0].id) {
                        nodes = matches;
                    }
                    // If single match is selected, show all nodes (don't filter)
                }

                // Tab Filter
                if (activeTab.value === 'Projects') {
                    let projects = nodes.filter(n => n.type === 'Project');
                    // If an org is selected, only show projects connected to that org
                    if (selected && selected.type === 'Institute') {
                        const connectedProjectIds = new Set();
                        graphData.links.forEach(l => {
                            if (l.source === selected.id) connectedProjectIds.add(l.target);
                            if (l.target === selected.id) connectedProjectIds.add(l.source);
                        });
                        projects = projects.filter(p => connectedProjectIds.has(p.id));
                    }
                    return projects;
                } else if (activeTab.value === 'Organizations') {
                    return nodes.filter(n => n.type === 'Institute');
                }
                return nodes; // Partnerships shows all
            });

            const filteredLinks = computed(() => {
                // Only show links in Partnerships tab
                if (activeTab.value !== 'Partnerships') return [];

                // Filter links where both source and target are in the filteredNodes list
                const nodeIds = new Set(filteredNodes.value.map(n => n.id));
                return graphData.links.filter(l => nodeIds.has(l.source) && nodeIds.has(l.target));
            });

            const connectedNodes = computed(() => {
                if (!selectedNode.value) return [];
                const selected = selectedNode.value;
                const connectedIds = new Set();
                graphData.links.forEach(l => {
                    if (l.source === selected.id) connectedIds.add(l.target);
                    if (l.target === selected.id) connectedIds.add(l.source);
                });
                return graphData.nodes.filter(n => connectedIds.has(n.id));
            });

            const initMap = async () => {
                const width = document.getElementById('map-container').clientWidth;
                const height = document.getElementById('map-container').clientHeight;

                svg = d3.select('#map-container').append('svg')
                    .attr('width', width)
                    .attr('height', height);

                // Group for map features
                const mapGroup = svg.append('g');
                // Group for network graph
                g = svg.append('g');

                // California Projection
                projection = d3.geoMercator()
                    .center([-119.5, 37.2]) // Center on CA
                    .scale(2500) // Zoom level
                    .translate([width / 2, height / 2]);

                path = d3.geoPath().projection(projection);

                // Initialize node positions from geographic coordinates
                graphData.nodes.forEach(node => {
                    const projected = projection(node.coordinates);
                    node.x = projected[0];
                    node.y = projected[1];
                    node.fx = null; // Allow nodes to move
                    node.fy = null;
                });

                // Create force simulation to prevent node overlap
                const collisionRadius = 2; // Minimal - just prevent direct overlap
                simulation = d3.forceSimulation(graphData.nodes)
                    .force('collision', d3.forceCollide().radius(collisionRadius).strength(0.5))
                    .force('x', d3.forceX(d => projection(d.coordinates)[0]).strength(0.05))
                    .force('y', d3.forceY(d => projection(d.coordinates)[1]).strength(0.05))
                    .alphaDecay(0.01)
                    .velocityDecay(0.6) // High friction
                    .on('tick', () => {
                        // Update node positions
                        g.selectAll('.node')
                            .attr('transform', d => `translate(${d.x}, ${d.y})`);

                        // Update link positions
                        g.selectAll('.link')
                            .attr('x1', d => graphData.nodes.find(n => n.id === d.source).x)
                            .attr('y1', d => graphData.nodes.find(n => n.id === d.source).y)
                            .attr('x2', d => graphData.nodes.find(n => n.id === d.target).x)
                            .attr('y2', d => graphData.nodes.find(n => n.id === d.target).y);
                    });

                // Zoom Behavior
                zoom = d3.zoom()
                    .scaleExtent([1, 8])
                    .on('zoom', (event) => {
                        mapGroup.attr('transform', event.transform);
                        g.attr('transform', event.transform);
                        currentZoomScale = event.transform.k;

                        // Restart simulation on zoom
                        simulation.alpha(0.3).restart();

                        // Scale nodes and links inversely to maintain constant visual size
                        const baseRadius = 8;
                        const baseStroke = 3;
                        const baseLinkStroke = 1;
                        const highlightedLinkStroke = 2.5;

                        g.selectAll('.node-circle')
                            .attr('r', function() {
                                const isSelected = d3.select(this).classed('selected');
                                return (isSelected ? 11 : baseRadius) / currentZoomScale;
                            })
                            .attr('stroke-width', baseStroke / currentZoomScale);

                        g.selectAll('.link')
                            .attr('stroke-width', function() {
                                const isHighlighted = d3.select(this).classed('highlighted');
                                return (isHighlighted ? highlightedLinkStroke : baseLinkStroke) / currentZoomScale;
                            });
                    });

                svg.call(zoom);

                // Load Topology - Using US Atlas from jsDelivr CDN
                try {
                    const usData = await d3.json('https://cdn.jsdelivr.net/npm/us-atlas@3/counties-10m.json');

                    const allCounties = topojson.feature(usData, usData.objects.counties);

                    // Filter to California counties only (FIPS codes starting with "06")
                    const caCounties = {
                        type: "FeatureCollection",
                        features: allCounties.features.filter(f => String(f.id).startsWith("06"))
                    };

                    mapGroup.selectAll('path')
                        .data(caCounties.features)
                        .enter().append('path')
                        .attr('class', 'county')
                        .attr('d', path);

                    renderGraph();

                    // Zoom to fit all nodes with padding
                    zoomToFitNodes(width, height);

                } catch (error) {
                    console.error("Error loading map data:", error);
                }
            };

            const zoomToFitNodes = (width, height) => {
                const padding = 240;
                const nodes = graphData.nodes;

                // Use simulated positions for bounding box
                const xExtent = d3.extent(nodes, d => d.x);
                const yExtent = d3.extent(nodes, d => d.y);

                const boxWidth = xExtent[1] - xExtent[0];
                const boxHeight = yExtent[1] - yExtent[0];
                const boxCenterX = (xExtent[0] + xExtent[1]) / 2;
                const boxCenterY = (yExtent[0] + yExtent[1]) / 2;

                // Calculate scale to fit with padding
                const scale = Math.min(
                    (width - padding * 2) / boxWidth,
                    (height - padding * 2) / boxHeight
                );

                // Calculate translation to center
                const translateX = width / 2 - boxCenterX * scale;
                const translateY = height / 2 - boxCenterY * scale;

                // Apply the initial transform
                const initialTransform = d3.zoomIdentity
                    .translate(translateX, translateY)
                    .scale(scale);

                svg.call(zoom.transform, initialTransform);
            };

            const renderGraph = () => {
                // Clear previous
                g.selectAll('*').remove();

                const currentNodes = filteredNodes.value;
                const currentLinks = filteredLinks.value;
                const selected = selectedNode.value;

                // Determine which node IDs are connected to the selected node
                const connectedIds = new Set();
                if (selected) {
                    graphData.links.forEach(l => {
                        if (l.source === selected.id) connectedIds.add(l.target);
                        if (l.target === selected.id) connectedIds.add(l.source);
                    });
                }

                // Draw Links
                const baseLinkStroke = 1;
                const highlightedLinkStroke = 2.5;

                g.selectAll('.link')
                    .data(currentLinks)
                    .enter().append('line')
                    .attr('class', d => {
                        if (selected && (d.source === selected.id || d.target === selected.id)) {
                            return 'link highlighted';
                        }
                        if (selected) {
                            return 'link faded';
                        }
                        return 'link';
                    })
                    .attr('stroke-width', d => {
                        const isHighlighted = selected && (d.source === selected.id || d.target === selected.id);
                        return (isHighlighted ? highlightedLinkStroke : baseLinkStroke) / currentZoomScale;
                    })
                    .attr('x1', d => graphData.nodes.find(n => n.id === d.source).x)
                    .attr('y1', d => graphData.nodes.find(n => n.id === d.source).y)
                    .attr('x2', d => graphData.nodes.find(n => n.id === d.target).x)
                    .attr('y2', d => graphData.nodes.find(n => n.id === d.target).y);

                // Draw Nodes
                const nodes = g.selectAll('.node')
                    .data(currentNodes)
                    .enter().append('g')
                    .attr('class', 'node')
                    .attr('transform', d => `translate(${d.x}, ${d.y})`)
                    .on('mouseover', (event, d) => {
                        tooltipData.value = d;
                        const t = tooltip.value;
                        t.style.opacity = 1;
                        t.style.left = (event.pageX) + 'px';
                        t.style.top = (event.pageY) + 'px';
                    })
                    .on('mouseout', () => {
                        tooltip.value.style.opacity = 0;
                    })
                    .on('click', (event, d) => {
                        // Toggle selection - click again to deselect
                        if (selectedNode.value && selectedNode.value.id === d.id) {
                            selectedNode.value = null;
                        } else {
                            searchQuery.value = '';
                            nextTick(() => {
                                selectedNode.value = d;
                                activeTab.value = 'Partnerships';
                            });
                        }
                        event.stopPropagation();
                    });

                // Node Circles - different colors for projects vs organizations
                const baseRadius = 8;
                const baseStroke = 3;

                nodes.append('circle')
                    .attr('class', d => {
                        let classes = 'node-circle';
                        if (d.type === 'Project') classes += ' project';
                        if (selected && d.id === selected.id) classes += ' selected';
                        // Fade nodes not connected to selected
                        if (selected && d.id !== selected.id && !connectedIds.has(d.id)) classes += ' faded';
                        return classes;
                    })
                    .attr('r', d => ((selected && d.id === selected.id) ? 11 : baseRadius) / currentZoomScale)
                    .attr('stroke-width', baseStroke / currentZoomScale);
            };

            // Function to handle tab selection - clears node selection
            const selectTab = (tab) => {
                selectedNode.value = null;
                activeTab.value = tab;
            };

            // Watch search query - auto-select if single result
            watch(searchQuery, (newQuery) => {
                if (newQuery) {
                    // Check if there's only one matching node
                    const q = newQuery.toLowerCase();
                    const matches = graphData.nodes.filter(n => n.name.toLowerCase().includes(q));

                    if (matches.length === 1) {
                        // Auto-select the single match (keep search text)
                        selectedNode.value = matches[0];
                        activeTab.value = 'Partnerships';
                    } else {
                        // Multiple or no matches - clear selection
                        selectedNode.value = null;
                    }
                } else {
                    // Empty search - clear selection
                    selectedNode.value = null;
                }
            });

            // Watch for state changes to re-render
            watch([activeTab, searchQuery, selectedNode], () => {
                renderGraph();
            });

            const zoomIn = () => {
                svg.transition().call(zoom.scaleBy, 1.3);
            };

            const zoomOut = () => {
                svg.transition().call(zoom.scaleBy, 0.7);
            };

            onMounted(() => {
                initMap();
                window.addEventListener('resize', () => {
                   d3.select('#map-container svg').remove();
                   initMap();
                });
            });

            return {
                tabs,
                activeTab,
                searchQuery,
                selectedNode,
                connectedNodes,
                tooltipData,
                tooltip,
                selectTab,
                zoomIn,
                zoomOut
            };
        }
    }).mount('#app');
</script>

</body>
</html>